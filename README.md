# Online Fair Allocation of Perishable Resources

**Manuscript:** Online Fair Allocation of Perishable Resources
  
**Authors:** Siddhartha Banerjee, Chamsi Hssaine, Sean R. Sinclair

## Citation

If you use this code or build on this work, please cite:

```bibtex
@article{banerjee2024online,
  title={Online Fair Allocation of Perishable Resources},
  author={Banerjee, Siddhartha and Hssaine, Chamsi and Sinclair, Sean R},
  journal={arXiv e-prints},
  pages={arXiv--2406},
  year={2024}
}
```


---

## 1. Overview

This repository contains all code required to reproduce the numerical experiments, tables, and figures in the paper Online Fair Allocation of Perishable Resources. The codebase implements online allocation algorithms under perishability, evaluates fairness–efficiency trade-offs, and reproduces all simulation results reported in the manuscript.

A typical replication workflow is:
	1.	Set up the computational environment (Section 4).
	2.	Run simulation scripts for synthetic or real-data settings (Section 5).
	3.	Run plotting and table-generation scripts to reproduce all figures and tables.

## 2. Data availability and provenance

This paper relies on both **synthetically generated data** and **real-world retail data**.

### Synthetic data
All synthetic datasets are generated by the authors using the scripts provided in this repository. No external data sources are required. The data-generating processes (including demand distributions, perishing rates, etc) are fully specified in the simulation scripts. Running these scripts reproduces the synthetic datasets used in the paper.

### Real-World Data
The real-world experiments use grocery store sales data from the paper [Data-Driven Dynamic Pricing and Ordering with Perishable Inventory in a Changing Environment
](https://pubsonline.informs.org/doi/10.1287/mnsc.2021.4011).  We do not include their dataset here, and instead run from the fit parameters from their data.

## 3. Variable dictionaries

Below we describe the key variables used across datasets and scripts.

### Common variables
- `NumGroups` (`n`) — number of groups (locations) in the instance.  
- `demands` — realized demand vector across groups.  
- `mean_size` — mean parameter of the synthetic demand distribution.  
- `var_size` — variance parameter of the synthetic demand distribution.  
- `max_budget` — total available resource, set to `mean_size * n` in simulations.  
- `resource_perish` — vector of perishing times for each unit of resource.  
- `alpha` — geometric perishing parameter controlling the perishability rate.  
- `xopt` — full-information optimal allocation fraction.  
- `x_lower_perish` — minimum feasible allocation accounting for perishability.  
- `x_lower_no_perish` — baseline minimum allocation ignoring perishability.  
- `n_upper` — feasibility bound computed via helper routines.  
- `Algorithm` — allocation policy being evaluated.  
- `num_iterations` — number of Monte Carlo repetitions per problem size.  

### Metrics

Each simulation records performance under multiple norms:

- `Hindsight_Envy` — envy relative to the ex post optimal allocation.  
- `Counterfactual_Envy` — envy under counterfactual reordering.  
- `Waste` — unallocated or unused resources.  
- `Perished_Un_Allocated` — resources that expired prior to allocation.  
- `Stockout` — unmet demand.  


## 4. Computational requirements

All code is written in **Python (>= 3.9)**.

Key dependencies include:
- numpy
- pandas
- scipy
- matplotlib
- seaborn
- lifelines
- statsmodels

We provide an **`environment.yml`** file specifying all required packages and versions to fully reproduce the computational environment. This environment can be created using:
```bash
conda env create -f environment.yml
conda activate robust_inventory
```

All random number generation uses fixed seeds where appropriate to ensure reproducibility. Some Monte Carlo benchmarks use large sample sizes (up to 1e7), which may require several minutes to run on a standard laptop.


## 5. Programs / Code

### Supplementary files
- `algorithms.py` implements all of the algorithms
- `helper.py` provides utility functions for calculating $\underline{X}$, $\Delta(X)$, etc

### Simulation scripts
- `run_uniform.py` runs the simulations under the non-iid perishing distribution with different allocation schedules
- `run_geometric.py` runs the simulations under (synthetic) Geometric perishing
- `run_geometric_tradeoff.py` runs the simulations under (synthetic) Geometric perishing to generate the trade-off curves
- `run_geometric_real_data.py` runs simulations using the real-world ginger perishing data

### Figure and table generation
- `uniform_plots.py` creates regret plots across different horizons and policies under the non-iid perishing model  
- `uniform_calculate_swap.py` computes SWAP statistics under different orderings 
- `uniform_data_swap_table.py` creates tables summarizing SWAP statistic across all orderings  
- `uniform_data_table.py` creates tables of average performance for each algorithm  
- `geometric_plots.py` produces main metric plots for the geometric perishing model  
- `geometric_tradeoff_figure.py` creates the fairness-efficiency tradeoff plot  
- `geometric_dperish_figure.py` and `fixed_point_dperish_figure.py` analyze perishing-related behaviors for the main text of the paper  
- `geometric_real_data_table.py` summarizes regret on real data using the geometric model  


All scripts use relative paths and can be run independently once the required data and environment are in place. Running the simulation scripts followed by the plotting/table scripts reproduces all main results in the paper.